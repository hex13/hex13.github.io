{"version":3,"sources":["utils.js","Sandbox.js","App.js","useLinearRegression.js","useAverage.js","serviceWorker.js","index.js"],"names":["lastId","createId","Sandbox","usePredict","w","h","React","useState","dots","i","y","push","x","Math","random","id","createDots","setDots","predict","title","className","width","height","onClick","e","bounds","target","getBoundingClientRect","dot","clientX","left","clientY","top","concat","viewBox","map","fill","key","cx","cy","r","filter","d","stopPropagation","stroke","strokeWidth","x1","y1","x2","y2","methods","minError","getCost","f","errorSum","forEach","error","length","m","b","bestM","bestB","undefined","sum","reduce","acc","App","idx","setIdx","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.bdc7b3ae.chunk.js","sourcesContent":["let lastId = 0;\n\nexport const createDots = () => {\n    const dots = [];\n    for (let i = -10; i < 10; i++) {\n        const y = i * 5;\n        dots.push({\n            x: i * 30 + ~~(Math.random() * 50),\n            y: y + ~~(Math.random() * 50),\n            id: createId(),\n        })\n    }\n    return dots;\n}\n\nexport const createId = () => ++lastId;","import React from 'react';\nimport './Sandbox.css';\nimport { createDots, createId } from './utils';\n\nexport function Sandbox({ usePredict }) {\n    const w = 600;\n    const h = 600;\n    const description = \"click to add/remove dots\";\n    const [dots, setDots] = React.useState(createDots());\n    const { predict, title } = usePredict(dots);\n    const addDot = (e) => {\n        const bounds = e.target.getBoundingClientRect();\n        const dot = {\n            id: createId(),\n            x: (e.clientX - bounds.left) - w / 2,\n            y: (e.clientY - bounds.top) - h / 2,\n        };\n        setDots(dots => dots.concat(dot));\n    }\n\n    return <div>\n        <h1>{ title  }</h1>\n        <svg \n            className=\"sandbox\"\n            width={w}\n            height={h}\n            onClick={addDot}\n            viewBox={`${- w / 2} ${- h / 2} ${w} ${h}`}\n        >\n            {\n                dots.map(dot => {\n                    return <circle \n                        className=\"dot\"\n                        fill=\"rgba(0, 0, 0, 0.4)\"\n                        key={dot.id}\n                        cx={dot.x} \n                        cy={dot.y} \n                        r={6}\n                        onClick={(e) => {\n                            setDots(dots => dots.filter(d => d.id != dot.id));\n                            e.stopPropagation();\n                        }}\n                    />;\n                })\n            }\n            <path d={`M ${-w/2} ${~~predict(-w/2)} L ${w/2} ${~~predict(w/2)}`}  stroke=\"red\" strokeWidth=\"2\"/>\n            <line x1={-w/2} y1=\"0\" x2={w/2} y2=\"0\" stroke=\"rgba(0, 0, 255, 0.5)\"/>\n            <line x1=\"0\" y1={-h/2} x2=\"0\" y2={h/2} stroke=\"rgba(0, 0, 255, 0.5)\" />\n        </svg>\n        <div>{ description }</div>\n        <button onClick={() => setDots([])}>clear</button>\n    </div>\n}","import React from 'react';\nimport { Sandbox } from './Sandbox';\nimport './App.css';\nimport { useLinearRegression } from './useLinearRegression';\nimport { useAverage } from './useAverage';\n\nconst methods = [useLinearRegression, useAverage];\n\nfunction App() {\n  const [idx, setIdx] = React.useState(0);\n  return (\n    <div className=\"App\">\n      <button onClick={() => setIdx(idx => (idx + methods.length- 1) % methods.length )}>prev</button>\n      <button onClick={() => setIdx(idx => (idx + 1) % methods.length)}>next</button>\n      <Sandbox usePredict={methods[idx]}/>\n    </div>\n  );\n}\n\nexport default App;\n","export function useLinearRegression(dots) {\n    const getCost = (dots, f) => {\n        let errorSum = 0;\n        dots.forEach(dot => {\n            const error = f(dot.x) - dot.y;\n            errorSum += error ** 2;\n        });\n        return errorSum / dots.length;\n    };\n\n    let m = 1;\n    let b = 0;\n    function f(x) {\n        return m * x + b;\n    }\n\n    let minError;\n    let bestM = 1;\n    let bestB = 0;\n\n    for (m = -20; m < 20; m += 0.2) {\n        for (b = -500; b < 600; b += 2) {\n            const error = getCost(dots, (x) => f(x));\n            if (minError == undefined || error < minError) {\n                minError = error;\n                bestB = b;\n                bestM = m;\n            }\n        }\n    }\n    b = bestB;\n    m = bestM;\n\n    return {\n        predict: f,\n        title: 'linear regression',\n    }\n};","export function useAverage(dots) {\n    const sum = dots.reduce((acc, dot) => acc + dot.y, 0);\n    return {\n        predict: () => sum / dots.length,\n        title: 'average',\n    }\n\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}